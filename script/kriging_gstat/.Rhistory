q()
x=matrix(c(2,2,6,1,6,0) ,3,2)
matrix (c(2,2,6,1,6,0) ,3,2,byrow=TRUE)
q()
q()
treino_x= c(2,6,6)
treino_y= c(2,1,0)
teste_x = c(2,2,6)
teste_y= c(1,6,0)
plot(treino_x, treino_y, col = c('red','blue','red',clim=c(0,9))
points(teste_x,teste_y, col = c('blue','red','blue'), pch=19)
treino_x= c(2,6,6)
treino_y= c(2,1,0)
teste_x = c(2,2,6)
teste_y= c(1,6,0)
plot(treino_x, treino_y, col = c('red','blue','red',xlim=c(0,9), ylim= c(0,9))
points(teste_x,teste_y, col = c('blue','red','blue'), pch=19)
plot.new(treino_x,treino_y, col=('re','blue','red', xlim= c(0,9), ylim=c(0,9)))
plot(treino_x, treino_y, col = c(('red','blue','red',xlim=c(0,9), ylim= c(0,9))
points(teste_x,teste_y, col = c('blue','red','blue'), pch=19)
plot(treino_x,treino_y,col=c('red','blue','red'),xlim=c(0,9),ylim=c(0,9))
points(teste_x,teste_y,col=c('blue','red','blue'),pch=19)
install.packages(c('hflights',',mlr', 'tidyverse'))
library(hflights)
library(mlr)
library(,mlr)
library(tidyverse)
install.packages("lubridate")
library(tidyverse)
install.packages("lubridate")
rm(list = ls()) #limpa as variaves criadas
library(ISLR)
install.packages("ISLR")
install.packages("ISLR")
library(ISLR)
install.packages(c("bindrcpp", "broom", "curl", "lme4", "lubridate", "plogr", "selectr"))
library(ISLR)
library(ISLR)
rm(list = ls()) #limpa as variaves criadas
library(ISLR)
library(tidyverse)
install.packages("dplyr")
cite(ape)
cite("ape")
citation("ape")
install.packages("ape")
citation("ape")
dados= dados%>% dplyr::select(-X.1,
-id,
-Potassio,
-MO,
-CTC,
-Fosforo,
-Argila,
-Eca_0.5_cor,
-eca_1.0)
dados = read.csv("./2amostra_ha.csv")
names(dados)
dados=na.omit(dados)
dados= dados%>% dplyr::select(-X.1,
-id,
-Potassio,
-MO,
-CTC,
-Fosforo,
-Argila,
-Eca_0.5_cor,
-eca_1.0)
library("ggpubr")
library(georob)
library(dplyr)
library(tidyverse)
library(pedometrics)
library(raster)
library(gstat)
#library(googlesheets)
library(mapview)
dados = read.csv("./2amostra_ha.csv")
names(dados)
dados=na.omit(dados)
dados= dados%>% dplyr::select(-X.1,
-id,
-Potassio,
-MO,
-CTC,
-Fosforo,
-Argila,
-Eca_0.5_cor,
-eca_1.0)
dados$coordx= dados$X - min(dados$X)
dados$coordy= dados$Y - min(dados$Y)
dat= dplyr::rename(dados, BS=Saturacao.por.bases,
banda_azul = b2,
banda_verde= b3,
banda_vermelho= b4,
banda_IVP = b5,
swir1= b6,
swir2=b7,
x=X,
y=Y)
dat$BS = as.numeric(dat$BS)
dat$elevacao= as.numeric(dat$elevacao)
dat$piquetes[dat$piquetes=="27"]=26
dat$piquetes[dat$piquetes=="28"]=26
dat$piquetes[dat$piquetes=="30"]=26
dat$piquetes= as.factor(dat$piquetes)
dat=na.omit(dat)
str(dat)
cor= dat %>%
as.data.frame()%>%
dplyr::select(-piquetes, -coordx, -coordy)%>%
correlate(method = "spearman", diagonal = 1)%>%
as.data.frame()
library(corrr)
cor= dat %>%
as.data.frame()%>%
dplyr::select(-piquetes, -coordx, -coordy)%>%
correlate(method = "spearman", diagonal = 1)%>%
as.data.frame()
cor_above =cor %>%
gather(-rowname, key = "colname", value = "cor") %>%
filter(abs(cor) < 1 & abs(cor) >= 0.9) %>%
dplyr::select(rowname, colname, cor) %>%
distinct(colname, cor) %>%
arrange(cor)
selected_var = cor_above[,"colname"]
cor_above =cor %>%
gather(-rowname, key = "colname", value = "cor") %>%
filter(abs(cor) < 1 & abs(cor) >= 0.9) %>%
dplyr::select(rowname, colname, cor) %>%
distinct(cor) %>%
arrange(cor)
View(cor_above)
cor_above =cor %>%
gather(-rowname, key = "colname", value = "cor") %>%
filter(abs(cor) < 1 & abs(cor) >= 0.9) %>%
dplyr::select(rowname, colname, cor) %>%
distinct(cor) %>%
select(BS)
cor_above =cor %>%
gather(-rowname, key = "colname", value = "cor") %>%
filter(abs(cor) < 1 & abs(cor) >= 0.9) %>%
dplyr::select(rowname, colname, cor) %>%
distinct(cor) %>%
dplyr::select(BS) %>%
arrange(cor)
selected_var = cor_above, cor %>%
selected_var = c(cor_above, cor) %>%
select(cor, BS)
selected_var = cor %>%
select(BS)
selected_var = cor %>%
dplyr::select(BS)
View(selected_var)
View(cor_above)
cor_above =cor %>%
gather(-rowname, key = "colname", value = "cor") %>%
filter(abs(cor) < 1 & abs(cor) >= 0.9) %>%
dplyr::select(rowname, colname, cor) %>%
distinct(cor) %>%
arrange(cor)
cor_above =cor %>%
gather(-rowname, key = "colname", value = "cor") %>%
filter(abs(cor) < 1 & abs(cor) >= 0.9) %>%
dplyr::select(rowname, colname, cor) %>%
distinct(cor, rowname) %>%
arrange(cor)
View(cor_above)
cor_above =cor %>%
gather(-rowname, key = "colname", value = "cor") %>%
filter(abs(cor) < 1 & abs(cor) >= 0.9) %>%
dplyr::select(rowname, colname, cor) %>%
distinct(cor, rowname,colname) %>%
arrange(cor)
View(cor_above)
cor_above =cor %>%
gather(-rowname, key = "colname", value = "cor") %>%
filter(abs(cor) < 1 & abs(cor) >= 0.9) %>%
dplyr::select(rowname, colname, cor) %>%
unique(cor, rowname,colname) %>%
arrange(cor)
values =
selected_var = cor %>%
dplyr::select(BS, var) %>%
get()
values =
selected_var = cor %>%
dplyr::select(BS, var)
names(cpr)
names(cor)
values =
selected_var = cor %>%
dplyr::select(BS, rowname)
View(cor)
View(selected_var)
names_above = cor$rowname
names_above = cor_above$rowname
names_above = unique(cor_above$rowname)
names_above
View(cor_above)
values =
selected_var = cor %>%
dplyr::select(BS, rowname) %>%
filter(rowname = names_above) %>%
arrange(BS)
View(selected_var)
values =
selected_var = cor %>%
dplyr::select(BS, rowname) %>%
filter(rowname == names_above) %>%
arrange(BS)
View(selected_var)
names_above
cor$rowname
values =
selected_var = cor %>%
dplyr::select(BS, rowname) %>%
get(rowname == names_above) %>%
arrange(BS)
values =
selected_var = cor %>%
dplyr::select(BS, rowname) %>%
filter(rowname == names_above) %>%
arrange(BS)
values =
selected_var = cor %>%
dplyr::select(BS, rowname) %>%
filter(name %in% names_above) %>%
arrange(BS)
values =
selected_var = cor %>%
dplyr::select(BS, rowname) %>%
filter(rowname %in% names_above) %>%
arrange(BS)
View(selected_var)
setwd("C:/Users/agda_/Google Drive/Doutorado/git_gstat/Kriging-in-R-with-gstat-package/script/kriging_gstat")
dados = read.csv(file = "Kriging/data/data points/data.csv", header = TRUE, sep = ',')
setwd("C:/Users/agda_/Google Drive/Doutorado/git_gstat/Kriging-in-R-with-gstat-package/script/kriging_gstat")
##1.4 - Loading data: our data is already free of outliers; we strongly recommend data preprocessing prior to interpolation
data = read.csv(file = "../../data/data points/data.csv", header = TRUE, sep = ',')
data <- data[,c(2,3,4)] #selecting important columns (x, y, z)
names(dados) <- c("x", "y", "z")
names(data) <- c("x", "y", "z")
sp::coordinates(data) = ~x+y # transform data to spatial object (x and y must be in UTM)
##1.5 - We separate the primary variable. This will facilitate analysis
solo_atr<- data$z
##1.6 - Data visualization according to the "z" values
sp::bubble(data, "z")
##2.1 - We start by visualization of the empirical variogram
g = gstat(id="solo_attr", formula = solo_atr ~ 1, data=data)
print(max(dist(data@coords))/2) # maximum distance between point coordinates (helps to limite variogram cutoff)
print(min(dist(data@coords))) # minimum distance between point coordinates (helps to define width)
library(gstat)
##2.1 - We start by visualization of the empirical variogram
g = gstat(id="solo_attr", formula = solo_atr ~ 1, data=data)
##2.2 - The variogram cloud
var_could = gstat::variogram(g, cloud=T)
cutoff = max(dist(data@coords))/2
##2.2 - The variogram cloud
var_could = gstat::variogram(g, cloud=T)
plot(var_could)
##2.3 Variogram map
It is possible to identify trend and anisotropy
var_map = gstat::variogram(g, cutoff=cutoff, width=100, map=T)
plot(var_map)
##2.4 - Experimental variogram by MoM
var_exp = gstat::variogram(g, cutoff=cutoff, width=100)
plot(var_exp)
g = gstat(id="solo_attr", formula = solo_atr ~ 1, data=data)
var_exp = gstat::variogram(g, cutoff=cutoff, width=100)
plot(var_exp)
##2.5 - Theorical variogram
We first use a "eye fit" to choose the variogram parameters - nugget effect, partial sill and range.
It can be fitted by a variety of models. Here we test spheric, exponential and gaussian models.
###2.5.1 - Spheric
fit.sph = fit.variogram(var_exp, vgm(0.15, "Sph", 250, 0.2)) # vgm(partial sill, model, range, nugget effect)
plot(var_exp, fit.sph)
###2.5.2 - Exponential
fit.exp = fit.variogram(var_exp, vgm(0.15, "Exp", 250, 0.2)) # vgm(partial sill, model, range, nugget effect)
plot(var_exp, fit.exp)
###2.5.3 - Gaussian
fit.gau = fit.variogram(var_exp, vgm(0.15, "Gau", 150, 0.2)) # vgm(partial sill, model, range, nugget effect)
plot(var_exp, fit.gau)
###3.1 - LOOCV of spheric model
xvalid.sph = krige.cv(z ~ 1, locations = data, model = fit.sph) # cross validation function
plot(xvalid.sph$var1.pred ~ solo_atr, cex = 1.2, lwd = 2) #, ylim=c(10,50), xlim=c(10,50))
abline(0, 1, col = "lightgrey", lwd = 2)
lm_sph = lm(xvalid.sph$var1.pred ~ solo_atr)
abline(lm_sph, col = "red", lwd = 2)
r2_sph = summary(lm_sph)$r.squared
rmse_sph = hydroGOF::rmse(xvalid.sph$var1.pred, solo_atr)
###3.2 - LOOCV of exponential model
xvalid.exp = krige.cv(z ~ 1, locations = data, model = fit.exp)
plot(xvalid.exp$var1.pred ~ dados$z, cex = 1.2, lwd = 2)
abline(0, 1, col = "lightgrey", lwd = 2)
lm_exp = lm(xvalid.exp$var1.pred ~ solo_atr)
abline(lm_exp,  col = "red", lwd = 2)
r2_exp = summary(lm_exp)$r.squared
rmse_exp = hydroGOF::rmse(xvalid.exp$var1.pred, solo_atr)
###3.3 - LOOCV of gaussian model
xvalid.gau = krige.cv(z ~ 1, locations = data, model = fit.gau)
plot(xvalid.gau$var1.pred ~ dados$z, cex = 1.2, lwd = 2)
abline(0, 1, col = "lightgrey", lwd = 2)
lm_gau = lm(xvalid.gau$var1.pred ~ solo_atr)
abline(lm_gau,  col = "red", lwd = 2)
r2_gau = summary(lm_gau)$r.squared # extrai R2
rmse_gau = hydroGOF::rmse(xvalid.gau$var1.pred, solo_atr)
##1.4 - Loading data: our data is already free of outliers; we strongly recommend data preprocessing prior to interpolation
data = read.csv(file = "../../data/data points/data.csv", header = TRUE, sep = ',')
data <- data[,c(2,3,4)] #selecting important columns (x, y, z)
names(data) <- c("x", "y", "z")
sp::coordinates(data) = ~x+y # transform data to spatial object (x and y must be in UTM)
##1.5 - We separate the primary variable. This will facilitate analysis
solo_atr<- data$z
##1.6 - Data visualization according to the "z" values
sp::bubble(data, "z")
##2.1 - We start by visualization of the empirical variogram
g = gstat(id="solo_attr", formula = solo_atr ~ 1, data=data)
print(max(dist(data@coords))/2) # maximum distance between point coordinates (helps to limite variogram cutoff)
print(min(dist(data@coords))) # minimum distance between point coordinates (helps to define width)
cutoff = max(dist(data@coords))/2
##2.2 - The variogram cloud
var_could = gstat::variogram(g, cloud=T)
plot(var_could)
##2.3 Variogram map
It is possible to identify trend and anisotropy
var_map = gstat::variogram(g, cutoff=cutoff, width=100, map=T)
plot(var_map)
##2.4 - Experimental variogram by MoM
var_exp = gstat::variogram(g, cutoff=cutoff, width=100)
plot(var_exp)
g = gstat(id="solo_attr", formula = solo_atr ~ 1, data=data)
var_exp = gstat::variogram(g, cutoff=cutoff, width=100)
plot(var_exp)
##1.4 - Loading data: our data is already free of outliers; we strongly recommend data preprocessing prior to interpolation
data = read.csv(file = "../../data/data points/data.csv", header = TRUE, sep = ',')
data <- data[,c(2,3,4)] #selecting important columns (x, y, z)
names(data) <- c("x", "y", "z")
sp::coordinates(data) = ~x+y # transform data to spatial object (x and y must be in UTM)
##1.5 - We separate the primary variable. This will facilitate analysis
solo_atr<- data$z
##1.6 - Data visualization according to the "z" values
sp::bubble(data, "z")
##2.1 - We start by visualization of the empirical variogram
g = gstat(id="solo_attr", formula = solo_atr ~ 1, data=data)
print(max(dist(data@coords))/2) # maximum distance between point coordinates (helps to limite variogram cutoff)
print(min(dist(data@coords))) # minimum distance between point coordinates (helps to define width)
cutoff = max(dist(data@coords))/2
##2.2 - The variogram cloud
var_could = gstat::variogram(g, cloud=T)
plot(var_could)
##2.3 Variogram map
It is possible to identify trend and anisotropy
var_map = gstat::variogram(g, cutoff=cutoff, width=100, map=T)
plot(var_map)
##2.4 - Experimental variogram by MoM
var_exp = gstat::variogram(g, cutoff=cutoff, width=100)
plot(var_exp)
g = gstat(id="solo_attr", formula = solo_atr ~ 1, data=data)
var_exp = gstat::variogram(g, cutoff=cutoff, width=100)
plot(var_exp)
##2.5 - Theorical variogram
We first use a "eye fit" to choose the variogram parameters - nugget effect, partial sill and range.
It can be fitted by a variety of models. Here we test spheric, exponential and gaussian models.
###2.5.1 - Spheric
fit.sph = fit.variogram(var_exp, vgm(0.15, "Sph", 250, 0.2)) # vgm(partial sill, model, range, nugget effect)
###2.5.1 - Spheric
fit.sph = fit.variogram(var_exp, vgm(0.004, "Sph", 450, 0.001)) # vgm(partial sill, model, range, nugget effect)
plot(var_exp, fit.sph)
###2.5.2 - Exponential
fit.exp = fit.variogram(var_exp, vgm(0.004, "Exp", 450, 0.001)) # vgm(partial sill, model, range, nugget effect)
plot(var_exp, fit.exp)
###2.5.3 - Gaussian
fit.gau = fit.variogram(var_exp, vgm(0.004, "Gau", 450, 0.001)) # vgm(partial sill, model, range, nugget effect)
plot(var_exp, fit.gau)
###3.1 - LOOCV of spheric model
xvalid.sph = krige.cv(z ~ 1, locations = data, model = fit.sph) # cross validation function
plot(xvalid.sph$var1.pred ~ solo_atr, cex = 1.2, lwd = 2) #, ylim=c(10,50), xlim=c(10,50))
abline(0, 1, col = "lightgrey", lwd = 2)
lm_sph = lm(xvalid.sph$var1.pred ~ solo_atr)
abline(lm_sph, col = "red", lwd = 2)
r2_sph = summary(lm_sph)$r.squared
rmse_sph = hydroGOF::rmse(xvalid.sph$var1.pred, solo_atr)
###3.2 - LOOCV of exponential model
xvalid.exp = krige.cv(z ~ 1, locations = data, model = fit.exp)
plot(xvalid.exp$var1.pred ~ dados$z, cex = 1.2, lwd = 2)
abline(0, 1, col = "lightgrey", lwd = 2)
lm_exp = lm(xvalid.exp$var1.pred ~ solo_atr)
abline(lm_exp,  col = "red", lwd = 2)
r2_exp = summary(lm_exp)$r.squared
rmse_exp = hydroGOF::rmse(xvalid.exp$var1.pred, solo_atr)
###3.3 - LOOCV of gaussian model
xvalid.gau = krige.cv(z ~ 1, locations = data, model = fit.gau)
plot(xvalid.gau$var1.pred ~ dados$z, cex = 1.2, lwd = 2)
abline(0, 1, col = "lightgrey", lwd = 2)
lm_gau = lm(xvalid.gau$var1.pred ~ solo_atr)
abline(lm_gau,  col = "red", lwd = 2)
r2_gau = summary(lm_gau)$r.squared # extrai R2
rmse_gau = hydroGOF::rmse(xvalid.gau$var1.pred, solo_atr)
##3.4 Visualization of LOOCV results
df.r2 = data.frame(r2_exp,r2_gau,r2_sph) #Set with R2
df.rmse = data.frame(rmse_exp, rmse_gau,rmse_sph) # Set with RMSE
temp = data.frame(cbind(t(df.r2), t(df.rmse))) # Join sets conjuntos
colnames(temp) = c('R2', 'RMSE')
rnames = gsub('r2_','',rownames(temp)) # Removes R2_ prefix from row names
rownames(temp) = rnames
print(temp)
View(temp)
contorno <- shapefile("../../data/boundary/cotorno.shp")
contorno <- raster::shapefile("../../data/boundary/cotorno.shp")
And then we create a grid
r = raster(contorno, res = 5) #  "res" sets pixel resolution
rp = rasterize(contorno, r, 0)
grid = as(rp, "SpatialPixelsDataFrame")
plot(grid)
contorno <- raster::shapefile("../../data/boundary/cotorno.shp")
r = raster(contorno, res = 5) #  "res" sets pixel resolution
r = raster::raster(contorno, res = 5) #  "res" sets pixel resolution
rp = rasterize(contorno, r, 0)
rp = raster::rasterize(contorno, r, 0)
grid = as(rp, "SpatialPixelsDataFrame")
plot(grid)
proj4string(data) = proj4string(contorno) # Contorno (shape) and data have the same CRS
sp::plot(grid)
proj4string(data) = raster::proj4string(contorno) # Contorno (shape) and data have the same CRS
raster::proj4string(data) = raster::proj4string(contorno) # Contorno (shape) and data have the same CRS
sp::proj4string(data) = sp::proj4string(contorno) # Contorno (shape) and data have the same CRS
##5.1 - Convert to raster
mapaRaster = raster(mapa)
##5.1 - Convert to raster
mapaRaster = raster::raster(mapa)
proj4string(mapaRaster) = proj4string(contorno)
mapa <- krige(solo_atr ~ 1, data, grid, model = fit.exp)
# incluindo argumento "block" permite fazer krigagem em bloco
plot(mapa)
We first convert maps format to raster and add the maps projection
##5.1 - Convert to raster
mapaRaster = raster::raster(mapa)
proj4string(mapaRaster) = proj4string(contorno)
mapa <- krige(solo_atr ~ 1, data, grid, model = fit.exp)
# incluindo argumento "block" permite fazer krigagem em bloco
plot(mapa)
##5.1 - Convert to raster
mapaRaster = raster::raster(mapa)
proj4string(mapaRaster) = proj4string(contorno)
library(sp)
proj4string(mapaRaster) = proj4string(contorno)
# Salvar a imagem do mapa
writeRaster(mapaRaster,
filename = './kriging/z_interpolated.tif',#here we choose where we want to save
format = 'GTiff',
overwrite = T)
library(raster)
# Salvar a imagem do mapa
writeRaster(mapaRaster,
filename = './kriging/z_interpolated.tif',#here we choose where we want to save
format = 'GTiff',
overwrite = T)
# Salvar a imagem do mapa
writeRaster(mapaRaster,
filename = '../../maps/z_interpolated.tif',#here we choose where we want to save
format = 'GTiff',
overwrite = T)
